# 42-Pong - Architecture & Requirements Context
# Created: December 30, 2025
# Last Updated: January 10, 2026
# Purpose: Reference document for project implementation
# Status: Server & Client fully implemented with JWT auth & Vault integration

project:
  name: 42-Pong
  description: Multiplayer Pong game with online and offline modes
  tech_stack:
    - TypeScript
    - Fastify (HTTP server)
    - Socket.IO (WebSocket communication)
    - Babylon.js (3D graphics engine)
    - Vite (build tool)
    - pong-shared (shared game engine, types & graphics)
    - HashiCorp Vault (secrets management)
    - JWT (authentication)
  server_port: 3005 (from env PORT, default 3005)
  server_host: from env HOST

# =============================================================================
# IMPLEMENTATION STATUS
# =============================================================================
status:
  server: IMPLEMENTED (Online/server/server.ts - 496 lines)
  client: IMPLEMENTED (Online/client/client.ts - 218 lines)
  offline_mode: IMPLEMENTED (Offline/src/main.ts - 102 lines)
  shared_library: IMPLEMENTED (Shared/src/)
  graphics_engine: IMPLEMENTED (Babylon.js + GUI)

# =============================================================================
# API ROUTES (REST)
# =============================================================================
api:
  prefix: /api/game
  authentication: JWT required (via @fastify/jwt)

  endpoints:
    matchmaking:
      method: GET
      path: /api/game/matchmaking
      auth: "JWT required (preHandler: jwtChecker)"
      description: |
        Find or create a room for matchmaking.
        - Validates user not already connected
        - If matchmaking queue has a waiting room → return that roomID
        - Else → create new room, add to queue, return roomID
      response:
        success: "{ roomId: string }"

    friendly_match:
      method: GET
      path: /api/game/friendly-match
      auth: "JWT required (preHandler: jwtChecker)"
      description: |
        Create a private room for friendly matches.
        - Room is NOT added to matchmaking queue
        - Share room ID with friend to join
      response:
        success: "{ roomId: string }"

    room_exists:
      method: GET
      path: /api/game/room/:roomid
      auth: "JWT required (preHandler: jwtChecker)"
      description: |
        Check if a room exists (for "Join Room" feature).
        Frontend uses this before redirecting user to game page.
        Room ID is normalized to uppercase.
      response:
        success: "{ exists: boolean }"

    spectate:
      method: GET
      path: /api/game/spectate
      auth: "JWT required (preHandler: jwtChecker)"
      description: |
        Find a random room with 2+ players for spectating.
        Returns null if no suitable rooms found.
      response:
        success: "{ roomId: string | null }"

    metrics:
      method: GET
      path: /metrics
      description: Prometheus metrics endpoint (fastify-metrics)

# =============================================================================
# SOCKET.IO EVENTS
# =============================================================================
socket:
  namespace: "/ (default, single namespace)"
  path: /api/game/socket.io/
  cors: "enabled (origin: '*', methods: ['GET', 'POST'])"
  
  # Uses Socket.IO rooms internally for game room separation
  # Room ID = 5 character random uppercase alphanumeric (e.g., "QGOAX")

  client_to_server:
    match:
      payload: "RoomData { roomId: string, PlayerID: string, playerName: string, playerAvatar: string }"
      response: "Match object (via acknowledgment callback)"
      timeout: "60000ms (client-side)"
      description: |
        Client joins a room after connecting.
        - Sends roomId, PlayerID, playerName, and playerAvatar
        - Validates room exists (normalized to uppercase)
        - Adds user to connectedUsers map
        - Assigns player side (1 or 2) or spectator (3)
        - Updates session with player name/avatar if player
        - Joins Socket.IO room
        - Emits 'side' event with assigned role
        - If 2 players present and state is 'Waiting':
          - Broadcasts 'session' event
          - Removes room from matchmaking queue
          - Increments match counter metric
          - Starts countdown
        - Returns Match object via callback

    input:
      payload: "Input (-1 | 0 | 1)"
      description: |
        Player sends paddle movement input.
        -1 = up, 0 = stop, 1 = down
        Only processed if sender is player (side 1 or 2) and game is "Playing".

  server_to_client:
    side:
      payload: number (1 = P1, 2 = P2, 3 = spectator)
      description: Tells client their role in the room.

    session:
      payload: Instance (session info with aliases and avatars)
      description: |
        Emitted when both players have joined.
        Also sent immediately to spectators joining mid-game.
        Client uses this to set up HUDs with correct player info.

    state:
      payload: GameState
      description: |
        Broadcasted every tick (60 FPS) to all clients in room.
        Contains: p1, p2 (scores), p1Y, p2Y (paddle positions),
        ballX, ballY, ballS (ball position and speed).

    gamestate:
      payload: "State (plain string: 'Waiting' | 'Countdown' | 'Playing' | 'Over')"
      description: |
        Emitted when game state changes.
        Sent as plain string, not wrapped in object.

    countdown:
      payload: "string (plain: 'GET READY!', '3', '2', '1', 'GO')"
      description: |
        Emitted during countdown before game starts.
        Sent as plain string, not wrapped in object.

    gameOver:
      payload: string (winner's alias)
      description: |
        Emitted when game ends.
        Just the winner's alias as a string, NOT an object.

    redirect:
      payload: (no data)
      description: |
        Emitted 5 seconds after game over.
        Client calls exitGame() which clicks hidden exit button.

# =============================================================================
# DATA STRUCTURES
# =============================================================================
data_structures:
  RoomMember:
    socket: Socket
    userID: string
    side: "1 | 2 | 3"              # 3 = spectator

  Player:                         # For game results
    userID: string
    win: boolean
    scored: number

  RoomData:                       # Client sends this when joining
    roomId: string
    PlayerID: string              # User ID from JWT
    playerName: string
    playerAvatar: string

  GameRoom:
    id: string                    # 5-char room ID
    engine: PongEngine            # From pong-shared
    members: "Map<socketId, RoomMember>"
    tick: "NodeJS.Timeout | null"   # Renamed from tickInterval
    session: Instance             # Game session info

  Instance:
    oppAI: boolean                # AI opponent (offline mode)
    diff: Diff                    # "None" | "Easy" | "Normal" | "Hard"
    p1Alias: string
    p1Avatar: string
    p2Alias: string
    p2Avatar: string

  AI:                             # AI state for offline mode
    diff: number                  # Difficulty factor
    target: number                # Predicted ball Y position

  Match:
    state: GameState              # Current game state
    currState: State              # "Waiting" | "Countdown" | "Playing" | "Over"
    session: Instance             # Session info

  GameState:
    p1: number                    # Player 1 score
    p2: number                    # Player 2 score
    p1Input: Input                # Player 1 input
    p2Input: Input                # Player 2 input
    p1X: number                   # Paddle 1 X position
    p1Y: number                   # Paddle 1 Y position
    p2X: number                   # Paddle 2 X position
    p2Y: number                   # Paddle 2 Y position
    ballX: number
    ballY: number
    ballS: number                 # Ball speed

  State: '"Waiting" | "Countdown" | "Playing" | "Over"'
  Input: "-1 | 0 | 1"
  Diff: '"None" | "Easy" | "Normal" | "Hard"'

  ServerState:
    rooms: Map<roomID, GameRoom>
    matchmakingQueue: string[]    # Room IDs waiting for opponent
    connectedUsers: Map<userID, Socket>  # Tracks connected users

# =============================================================================
# GAME CONSTANTS (from Shared/src/constants.ts)
# =============================================================================
constants:
  WIDTH: 640
  HEIGHT: 480
  PWIDTH: 20                      # Paddle width
  PHEIGHT: 80                     # Paddle height
  PSPEED: 400                     # Paddle speed
  BSPEED: 300                     # Initial ball speed
  BRADIUS: 10                     # Ball radius
  ULGAP: 5                        # Upper left gap (paddle boundary)
  DRGAP: 395                      # Down right gap (HEIGHT - PHEIGHT - 5)
  TICKRATE: 60
  TICKDT: 0.0166667               # 1/60 seconds

  keyMap:                         # Keyboard input mapping
    w: { player: "p1Input", value: -1 }
    a: { player: "p1Input", value: -1 }
    s: { player: "p1Input", value: 1 }
    d: { player: "p1Input", value: 1 }
    arrowup: { player: "p2Input", value: -1 }
    arrowleft: { player: "p2Input", value: -1 }
    arrowdown: { player: "p2Input", value: 1 }
    arrowright: { player: "p2Input", value: 1 }

  diffMap:                        # AI difficulty mapping
    None: 0
    Easy: 2
    Normal: 4
    Hard: 8

# =============================================================================
# AUTHENTICATION & SECURITY
# =============================================================================
authentication:
  method: JWT (JSON Web Token)
  library: "@fastify/jwt"
  secret_source: HashiCorp Vault
  vault:
    endpoint: from env VAULT_ADDR
    token: from env PONG_SERVICE_TOKEN
    secret_path: from env VAULT_SECRET_PATH
  jwt_checker:
    - Verifies JWT token from request
    - Checks if user is already connected (prevents duplicate connections)
    - Returns 401 Unauthorized if invalid or duplicate

# =============================================================================
# GAME FLOW
# =============================================================================
game_flow:
  matchmaking:
    1: "Frontend calls GET /api/game/matchmaking with JWT"
    2: "Server validates JWT and checks user not already connected"
    3: "Server returns roomId (existing waiting room or new)"
    4: "Frontend stores RoomData {roomId, PlayerID, playerName, playerAvatar} as JSON in sessionStorage 'room'"
    5: "Frontend redirects to game page"
    6: "Client parses 'room' from sessionStorage, connects socket"
    7: "Client emits 'match' with RoomData {roomId, PlayerID, playerName, playerAvatar}"
    8: "Server assigns as Player 1, adds to connectedUsers, sets player name/avatar, waits for opponent"
    9: "When Player 2 joins and state is 'Waiting' → broadcast session → countdown → game starts"

  friendly_match:
    1: "User requests private room via GET /api/game/friendly-match"
    2: "Server creates room but does NOT add to matchmaking queue"
    3: "User shares room ID with friend"
    4: "Friend joins via room ID (GET /api/game/room/:roomid then socket)"
    5: "Same flow as matchmaking after both players connected"

  join_room:
    1: "User enters room ID in frontend"
    2: "Frontend calls GET /api/game/room/:roomid to validate"
    3: "If exists → store RoomData in sessionStorage 'room', redirect to game"
    4: "Client parses 'room', connects, emits 'match' with RoomData"
    5: "Server assigns as Player 2 (if slot available) or Spectator"
    6: "If now 2 players → broadcast session → countdown → game starts"

  spectate:
    1: "Frontend calls GET /api/game/spectate"
    2: "Server returns random room with 2+ players (or null)"
    3: "If room found → store RoomData, redirect to game"
    4: "Client joins, receives 'side' = 3 (spectator)"
    5: "Client receives 'session' event, sets up HUDs"
    6: "Client calls catchUpGoals() to sync score display"

  gameplay:
    tick_rate: 60 FPS (TICKDT = 1/60)
    win_condition: First to 5 goals
    ball_speed_increase: +50 per paddle hit (max 800)
    physics: Server-authoritative (PongEngine runs on server)
    broadcast: State sent to all room members every tick

  game_results:
    description: |
      When game ends, server sends results to user-service.
      PUT /api/user/match/result with {p1, p2} Player objects.
    endpoint: "{USER_SERVICE_URL}/api/user/match/result"
    method: PUT
    payload: "{ p1: Player, p2: Player }"

  disconnection:
    player_disconnects:
      - "Remove from connectedUsers map"
      - "Game ends immediately if state is 'Playing' or 'Countdown'"
      - "handleGameOver called with disconnectedSide"
      - "Remaining player wins"
      - "Room cleanup triggered when all members leave"
    spectator_disconnects:
      - "Remove from members map"
      - "No effect on game"
      - "Room cleanup if empty"

# =============================================================================
# SPECTATORS
# =============================================================================
spectators:
  enabled: true
  assignment: |
    Any client joining a room that already has 2 players
    becomes a spectator (side = 3).
  capabilities:
    - Receive state updates
    - Watch game in real-time
    - Receive session info immediately on join
    - Can catch up on current score via catchUpGoals()
  restrictions:
    - Cannot send input (input handler checks playerSide === 3)
    - No effect on game outcome

# =============================================================================
# ROOM MANAGEMENT
# =============================================================================
room_management:
  id_format: "5 random uppercase alphanumeric characters (e.g., QGOAX)"
  id_generation: "Recursive if collision detected"
  timeout: None (rooms persist until manually cleaned)
  cleanup_triggers:
    - All members disconnect (room.members.size === 0)
    - Game ends and all players redirect
  cleanup_actions:
    - Clear tick interval
    - Remove room from rooms Map
    - Remove from matchmaking queue if present
  max_concurrent_users: ~20 (small project scale)
  private_rooms: via /api/game/friendly-match endpoint

# =============================================================================
# COUNTDOWN
# =============================================================================
countdown:
  duration: ~5 seconds total
  trigger: When 2 players are in the room and state is "Waiting"
  flow:
    - "Set engine state to 'Countdown'"
    - "Broadcast gamestate 'Countdown'"
    - "Emit countdown 'GET READY!', wait 2s"
    - "Emit countdown '3', wait 1s"
    - "Emit countdown '2', wait 1s"
    - "Emit countdown '1', wait 1s"
    - "Emit countdown 'GO'"
    - "Set engine state to 'Playing'"
    - "Broadcast gamestate 'Playing'"
    - "Start game loop"

# =============================================================================
# GAME OVER & REDIRECT
# =============================================================================
game_over:
  triggers:
    - "Player scores 5 goals (engine detects via getWinner())"
    - "Player disconnects during Playing or Countdown"
  flow:
    1: "Set engine state to 'Over'"
    2: "Clear tick interval"
    3: "Determine winner (from engine or by disconnectedSide)"
    4: "Emit 'gamestate' with 'Over'"
    5: "Emit 'gameOver' with winner alias (string)"
    6: "Call sendGameResults() to persist to user-service"
    7: "Wait 5 seconds"
    8: "Emit 'redirect' (no payload)"
    9: "Room cleanup on socket disconnect"
  redirect:
    event: "redirect"
    payload: none
    note: |
      Client receives redirect event and calls exitGame().
      exitGame() clicks hidden exit button to navigate away.

# =============================================================================
# CLIENT IMPLEMENTATION
# =============================================================================
client:
  file: Online/client/client.ts
  lines: 218
  features_implemented:
    - Socket.IO connection with path /api/game/socket.io/
    - Match acknowledgment callback
    - State mirroring for Player 2
    - Session mirroring for Player 2 (swap aliases/avatars)
    - Input handling (keydown/keyup)
    - Babylon.js 3D rendering
    - HUD display with player info (via session event)
    - Camera switching (keys 1-4)
    - Color customization options
    - Countdown display (GET READY!, 3, 2, 1, GO)
    - Game over display
    - Redirect handling via exitGame()
    - Error handling with fallback to dashboard
    - Spectator catch-up (catchUpGoals)

  mirroring:
    enabled: true
    description: |
      Player 2's view is mirrored so they see themselves on the right side.
      modifyState(): Swaps p1/p2 scores, p1Y/p2Y positions, ballX flipped (WIDTH - ballX).
      Session mirroring: Swaps p1/p2 aliases and avatars.
    function: modifyState()

  controls:
    online:
      - "w/a: up (-1)"
      - "s/d: down (1)"
      - "ArrowUp/Left: up (-1)"
      - "ArrowDown/Right: down (1)"
      - "keyup: stop (0)"
    cameras:
      - "1: Classic (top-down)"
      - "2: Pilot (side view)"
      - "3: Spectator (angled)"
      - "4: FreeCam (arc rotate, interactive)"

# =============================================================================
# OFFLINE MODE
# =============================================================================
offline_mode:
  file: Offline/src/main.ts
  lines: 102
  features:
    - Local PongEngine instance
    - AI opponent support (with difficulty levels)
    - Same Babylon.js graphics as online
    - setInterval game loop with TICKDT * 1000
    - requestAnimationFrame render loop
    - Session storage for game configuration
    - Start button with countdown UI (via startButton())
    - Game over handling with auto-exit after 3 seconds

# =============================================================================
# GRAPHICS SYSTEM (Babylon.js)
# =============================================================================
graphics:
  engine: Babylon.js 8.43.0
  modules:
    game_scene:
      file: Shared/src/graphics/game-scene.ts
      lines: 52
      exports: createScene()
      returns: GameScene { engine, scene, cameras }
      creates: Engine, Scene, Lights (DirectionalLight x2, HemisphericLight), 4 Cameras
      features:
        - Custom PongLoading loading screen
        - 2-second loading screen delay
    
    meshes:
      file: Shared/src/graphics/meshes.ts
      lines: 59
      exports: createSky(), createArena(), createPaddles(), createBall()
      features:
        - Sky sphere with space texture
        - Arena with ground and walls (merged mesh)
        - Ball with PointLight glow effect
    
    materials:
      file: Shared/src/graphics/materials.ts
      lines: 69
      exports: createArenaMaterial(), createSkyMaterial(), createPaddleMaterial(), createBallMaterial()
      features:
        - PBR glass material for arena
        - Standard material with emissive texture for sky
        - Grid materials for paddles and ball
    
    renderer:
      file: Shared/src/graphics/renderer.ts
      lines: 116
      exports: Renderer class, PongLoading class, GameMeshes interface
      class: Renderer
      methods: render(), updateGameState(), worldPosition(), paddlePosition(), getActiveCamera(), setActiveCamera(), runRenderLoop(), dispose()
      features:
        - Custom loading screen (PongLoading class)
        - Smooth opacity transition on load complete
    
    gui:
      file: Shared/src/graphics/gui.ts
      lines: 354
      exports: createGUI(), loadGameFont(), optionsButton(), addHUDs(), updateGoals(), catchUpGoals(), startButton(), createSign()
      features:
        - Player HUDs with avatars and aliases
        - Score tracking with goal icons
        - Camera switch buttons (4 buttons)
        - Color picker for ball and paddles (3 buttons)
        - Options panel toggle
        - Start button for offline mode
        - Sign display for countdown/messages
        - Font loading (Press Start 2P)

# =============================================================================
# DEPENDENCIES
# =============================================================================
dependencies:
  online:
    - pong-shared: "file:../Shared"
    - fastify: "^5.6.2"
    - fastify-metrics: "^12.1.0"
    - "@fastify/jwt": "^10.0.0"
    - node-vault: "^0.10.9"
    - socket.io: "^4.8.3"
    - socket.io-client: "^4.8.3"
    - typescript: "^5.9.3"
    - vite: "^7.3.0"

  offline:
    - pong-shared: "file:../Shared"
    - typescript: "^5.9.3"
    - vite: "^7.3.0"

  shared:
    - "@babylonjs/core": "^8.43.0"
    - "@babylonjs/materials": "^8.43.0"
    - "@babylonjs/gui": "^8.43.0"
    - typescript: "^5.9.3"

# =============================================================================
# FILE STRUCTURE
# =============================================================================
file_structure:
  Pong/:
    Assets/:                      # Game assets (images, SVGs, etc.)
      - ai.png                    # AI avatar
      - ball.svg                  # Ball color button icon
      - button.svg                # Start button background
      - cam1.svg - cam4.svg       # Camera switch icons
      - default.png               # Default avatar
      - goal.svg                  # Goal indicator icon
      - loading.gif               # Loading animation
      - options.svg               # Options button icon
      - p1.svg, p2.svg            # Paddle color button icons
      - player1.svg, player2.svg  # HUD backgrounds
      - sign.png                  # Sign background
      - space.png                 # Skybox texture
    context.yaml:                 # This file
    init.sh:                      # Initialization script
    Dockerfile.pong.prod:         # Production Dockerfile
    Dockerfile.pong.prod.multistage:  # Multi-stage Dockerfile

  Online/:
    package.json:                 # Dependencies configured
    server/:
      server.ts:                  # Main server file (496 lines)
      tsconfig.json:              # Server TypeScript config
    client/:
      client.ts:                  # Game client (218 lines)
      index.html:                 # Client HTML entry
      tsconfig.json:              # Client TypeScript config
      vite.config.ts:             # Vite config for client

  Offline/:
    package.json:                 # Dependencies configured
    src/:
      main.ts:                    # Offline game entry (102 lines)
    index.html:                   # Offline HTML entry
    tsconfig.json:                # TypeScript config
    vite.config.ts:               # Vite config

  Shared/:
    package.json:                 # Dependencies configured
    tsconfig.json:                # TypeScript config
    src/:
      index.ts:                   # Re-exports all modules
      types.ts:                   # Type definitions (Input, State, Instance, AI, etc.)
      constants.ts:               # Game constants (WIDTH, HEIGHT, TICKDT, keyMap, diffMap)
      game-engine.ts:             # PongEngine class (258 lines)
      graphics/:
        game-scene.ts:            # Babylon.js scene setup (52 lines)
        materials.ts:             # Materials (PBR, Grid) (69 lines)
        meshes.ts:                # 3D mesh creation (59 lines)
        renderer.ts:              # Renderer + PongLoading class (116 lines)
        gui.ts:                   # GUI/HUD system (354 lines)

# =============================================================================
# NPM SCRIPTS
# =============================================================================
scripts:
  online:
    build:client: "cd client && tsc && vite build"
    build:server: "cd server && tsc"
    build: "npm run build:client && npm run build:server"
  
  offline:
    build: "tsc && vite build"
  
  shared:
    build: "tsc"

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
environment:
  HOST: Server bind address
  PORT: Server port (default 3005)
  SERVICE_EXT: Service extension for Docker (default '-dev')
  VAULT_ADDR: HashiCorp Vault address
  VAULT_SECRET_PATH: Path to secrets in Vault
  PONG_SERVICE_TOKEN: Vault token for pong service
  LOG_LEVEL: Logging level (default 'info')
  NODE_ENV: Environment (default 'development')

# =============================================================================
# METRICS (Prometheus)
# =============================================================================
metrics:
  library: fastify-metrics
  endpoint: /metrics
  custom_metrics:
    matches_total:
      type: Counter
      description: Total number of matches started
      incremented_on: Both players joined and countdown starts

# =============================================================================
# EXTERNAL SERVICE INTEGRATION
# =============================================================================
integrations:
  user_service:
    url: "http://user-service{SERVICE_EXT}:3002"
    endpoints:
      match_result:
        method: PUT
        path: /api/user/match/result
        payload: "{ p1: Player, p2: Player }"
        description: Sends game results when match ends
