# Use a high, custom ID (like 900999) to avoid colliding with CRS defaults (900200)
SecAction \
  "id:900999,\
  phase:1,\
  nolog,\
  pass,\
  t:none,\
  setvar:'tx.allowed_methods=GET POST PUT DELETE'"


SecRule FILES_TMPNAMES "@inspectFile /usr/local/bin/scan_php.sh" \
    "id:999001,\
    phase:2,\
    deny,\
    log,\
    msg:'File Inspection Failed: Malicious Content or Invalid Format',\
    logdata:'%{matched_var}',\
    status:403"


SecRule FILES "@rx \.(?i:php|pl|py|sh|exe|cmd|bat|phtml)\." \
    "id:999002,\
    phase:2,\
    deny,\
    log,\
    msg:'Blocked Double Extension Attack',\
    status:403"





# in fastify:
# import { fileTypeFromBuffer } from 'file-type';

# fastify.post('/upload', async (req, reply) => {
#     const data = await req.file(); // Get the multipart file

#     // 1. Convert the file stream to a Buffer (puts it in RAM)
#     const buffer = await data.toBuffer();

#     // 2. INSPECT THE MAGIC BYTES
#     // This function looks at the binary signature, NOT the filename extension
#     const type = await fileTypeFromBuffer(buffer);

#     // 3. Validation Logic
#     const allowedMimes = ['image/jpeg', 'image/png', 'image/gif'];

#     // If type is undefined (unknown) or not in our allowed list
#     if (!type || !allowedMimes.includes(type.mime)) {
#         return reply.code(400).send({ error: 'Invalid file type. Real type detected: ' + (type ? type.mime : 'unknown') });
#     }

#     // 4. If valid, proceed to save the file
#     // fs.writeFileSync(...)
# });